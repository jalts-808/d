<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="3" failures="3" skipped="0" tests="3" time="1.073" timestamp="2024-11-29T19:47:11.543061-05:00" hostname="Jaltss-MBP"><testcase classname="ecom.cart.tests.test_views.TestCartViews" name="test_cart_summary" time="0.381"><failure message="ValueError: Missing staticfiles manifest entry for 'assets/favicon.ico'">self = &lt;test_views.TestCartViews object at 0x106a7c3e0&gt;
client = &lt;django.test.client.Client object at 0x106d38f50&gt;

    def test_cart_summary(self, client):
        """Test the cart summary view."""
        client.login(username="testuser", password="testpass")
        url = reverse("cart-summary")
&gt;       response = client.get(url)

ecom/cart/tests/test_views.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv/lib/python3.12/site-packages/django/test/client.py:1049: in get
    response = super().get(path, data=data, secure=secure, headers=headers, **extra)
venv/lib/python3.12/site-packages/django/test/client.py:465: in get
    return self.generic(
venv/lib/python3.12/site-packages/django/test/client.py:617: in generic
    return self.request(**r)
venv/lib/python3.12/site-packages/django/test/client.py:1013: in request
    self.check_exception(response)
venv/lib/python3.12/site-packages/django/test/client.py:743: in check_exception
    raise exc_value
venv/lib/python3.12/site-packages/django/core/handlers/exception.py:55: in inner
    response = get_response(request)
venv/lib/python3.12/site-packages/django/core/handlers/base.py:197: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
ecom/cart/views.py:19: in cart_summary
    return render(request, "cart/cart_summary.html", context)
venv/lib/python3.12/site-packages/django/shortcuts.py:25: in render
    content = loader.render_to_string(template_name, context, request, using=using)
venv/lib/python3.12/site-packages/django/template/loader.py:62: in render_to_string
    return template.render(context, request)
venv/lib/python3.12/site-packages/django/template/backends/django.py:61: in render
    return self.template.render(context)
venv/lib/python3.12/site-packages/django/template/base.py:171: in render
    return self._render(context)
venv/lib/python3.12/site-packages/django/test/utils.py:111: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.12/site-packages/django/template/base.py:1000: in render
    return SafeString("".join([node.render_annotated(context) for node in self]))
venv/lib/python3.12/site-packages/django/template/base.py:961: in render_annotated
    return self.render(context)
venv/lib/python3.12/site-packages/django/template/loader_tags.py:159: in render
    return compiled_parent._render(context)
venv/lib/python3.12/site-packages/django/test/utils.py:111: in instrumented_test_render
    return self.nodelist.render(context)
venv/lib/python3.12/site-packages/django/template/base.py:1000: in render
    return SafeString("".join([node.render_annotated(context) for node in self]))
venv/lib/python3.12/site-packages/django/template/base.py:961: in render_annotated
    return self.render(context)
venv/lib/python3.12/site-packages/django/templatetags/static.py:116: in render
    url = self.url(context)
venv/lib/python3.12/site-packages/django/templatetags/static.py:113: in url
    return self.handle_simple(path)
venv/lib/python3.12/site-packages/django/templatetags/static.py:129: in handle_simple
    return staticfiles_storage.url(path)
venv/lib/python3.12/site-packages/django/contrib/staticfiles/storage.py:203: in url
    return self._url(self.stored_name, name, force)
venv/lib/python3.12/site-packages/django/contrib/staticfiles/storage.py:182: in _url
    hashed_name = hashed_name_func(*args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;whitenoise.storage.CompressedManifestStaticFilesStorage object at 0x10704f1a0&gt;
name = 'assets/favicon.ico'

    def stored_name(self, name):
        parsed_name = urlsplit(unquote(name))
        clean_name = parsed_name.path.strip()
        hash_key = self.hash_key(clean_name)
        cache_name = self.hashed_files.get(hash_key)
        if cache_name is None:
            if self.manifest_strict:
&gt;               raise ValueError(
                    "Missing staticfiles manifest entry for '%s'" % clean_name
                )
E               ValueError: Missing staticfiles manifest entry for 'assets/favicon.ico'

venv/lib/python3.12/site-packages/django/contrib/staticfiles/storage.py:516: ValueError</failure></testcase><testcase classname="ecom.cart.tests.test_views.TestCartViews" name="test_cart_summary" time="0.000"><error message="failed on teardown with &quot;django.db.utils.IntegrityError: The row in table 'store_product' with primary key '1' has an invalid foreign key: store_product.category_id contains a value '1' that does not have a corresponding value in store_category.id.&quot;">request = &lt;SubRequest '_django_db_helper' for &lt;Function test_cart_summary&gt;&gt;
django_db_setup = None
django_db_blocker = &lt;pytest_django.plugin.DjangoDbBlocker object at 0x1056350d0&gt;

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -&gt; Generator[None, None, None]:
        from django import VERSION
    
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        django_db_blocker.unblock()
    
        import django.db
        import django.test
    
        if transactional:
            test_case_class = django.test.TransactionTestCase
        else:
            test_case_class = django.test.TestCase
    
        _reset_sequences = reset_sequences
        _serialized_rollback = serialized_rollback
        _databases = databases
        _available_apps = available_apps
    
        class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
            reset_sequences = _reset_sequences
            serialized_rollback = _serialized_rollback
            if _databases is not None:
                databases = _databases
            if _available_apps is not None:
                available_apps = _available_apps
    
            # For non-transactional tests, skip executing `django.test.TestCase`'s
            # `setUpClass`/`tearDownClass`, only execute the super class ones.
            #
            # `TestCase`'s class setup manages the `setUpTestData`/class-level
            # transaction functionality. We don't use it; instead we (will) offer
            # our own alternatives. So it only adds overhead, and does some things
            # which conflict with our (planned) functionality, particularly, it
            # closes all database connections in `tearDownClass` which inhibits
            # wrapping tests in higher-scoped transactions.
            #
            # It's possible a new version of Django will add some unrelated
            # functionality to these methods, in which case skipping them completely
            # would not be desirable. Let's cross that bridge when we get there...
            if not transactional:
    
                @classmethod
                def setUpClass(cls) -&gt; None:
                    super(django.test.TestCase, cls).setUpClass()
                    if VERSION &lt; (4, 1):
                        django.db.transaction.Atomic._ensure_durability = False
    
                @classmethod
                def tearDownClass(cls) -&gt; None:
                    if VERSION &lt; (4, 1):
                        django.db.transaction.Atomic._ensure_durability = True
                    super(django.test.TestCase, cls).tearDownClass()
    
        PytestDjangoTestCase.setUpClass()
    
        test_case = PytestDjangoTestCase(methodName="__init__")
        test_case._pre_setup()
    
        yield
    
&gt;       test_case._post_teardown()

venv/lib/python3.12/site-packages/pytest_django/fixtures.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv/lib/python3.12/site-packages/django/test/testcases.py:1102: in _post_teardown
    self._fixture_teardown()
venv/lib/python3.12/site-packages/django/test/testcases.py:1333: in _fixture_teardown
    connections[db_name].check_constraints()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;DatabaseWrapper vendor='sqlite' alias='default'&gt;, table_names = None

    def check_constraints(self, table_names=None):
        """
        Check each table name in `table_names` for rows with invalid foreign
        key references. This method is intended to be used in conjunction with
        `disable_constraint_checking()` and `enable_constraint_checking()`, to
        determine if rows with invalid references were entered while constraint
        checks were off.
        """
        with self.cursor() as cursor:
            if table_names is None:
                violations = cursor.execute("PRAGMA foreign_key_check").fetchall()
            else:
                violations = chain.from_iterable(
                    cursor.execute(
                        "PRAGMA foreign_key_check(%s)" % self.ops.quote_name(table_name)
                    ).fetchall()
                    for table_name in table_names
                )
            # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
            for (
                table_name,
                rowid,
                referenced_table_name,
                foreign_key_index,
            ) in violations:
                foreign_key = cursor.execute(
                    "PRAGMA foreign_key_list(%s)" % self.ops.quote_name(table_name)
                ).fetchall()[foreign_key_index]
                column_name, referenced_column_name = foreign_key[3:5]
                primary_key_column_name = self.introspection.get_primary_key_column(
                    cursor, table_name
                )
                primary_key_value, bad_value = cursor.execute(
                    "SELECT %s, %s FROM %s WHERE rowid = %%s"
                    % (
                        self.ops.quote_name(primary_key_column_name),
                        self.ops.quote_name(column_name),
                        self.ops.quote_name(table_name),
                    ),
                    (rowid,),
                ).fetchone()
&gt;               raise IntegrityError(
                    "The row in table '%s' with primary key '%s' has an "
                    "invalid foreign key: %s.%s contains a value '%s' that "
                    "does not have a corresponding value in %s.%s."
                    % (
                        table_name,
                        primary_key_value,
                        table_name,
                        column_name,
                        bad_value,
                        referenced_table_name,
                        referenced_column_name,
                    )
                )
E               django.db.utils.IntegrityError: The row in table 'store_product' with primary key '1' has an invalid foreign key: store_product.category_id contains a value '1' that does not have a corresponding value in store_category.id.

venv/lib/python3.12/site-packages/django/db/backends/sqlite3/base.py:276: IntegrityError</error></testcase><testcase classname="ecom.cart.tests.test_views.TestCartViews" name="test_cart_add" time="0.297"><failure message="assert 1 == 2">self = &lt;test_views.TestCartViews object at 0x106a7dac0&gt;
client = &lt;django.test.client.Client object at 0x10709fa70&gt;

    def test_cart_add(self, client):
        """Test adding a product to the cart."""
        client.login(username="testuser", password="testpass")
        url = reverse("cart-add")
        response = client.post(url, {"product_id": self.product.id, "product_qty": 2, "action": "post"})
        assert response.status_code == 200
&gt;       assert response.json()["qty"] == 2  # Assuming the cart initially had 0 items
E       assert 1 == 2

ecom/cart/tests/test_views.py:29: AssertionError</failure></testcase><testcase classname="ecom.cart.tests.test_views.TestCartViews" name="test_cart_add" time="0.000"><error message="failed on teardown with &quot;django.db.utils.IntegrityError: The row in table 'store_product' with primary key '1' has an invalid foreign key: store_product.category_id contains a value '1' that does not have a corresponding value in store_category.id.&quot;">request = &lt;SubRequest '_django_db_helper' for &lt;Function test_cart_add&gt;&gt;, django_db_setup = None
django_db_blocker = &lt;pytest_django.plugin.DjangoDbBlocker object at 0x1056350d0&gt;

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -&gt; Generator[None, None, None]:
        from django import VERSION
    
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        django_db_blocker.unblock()
    
        import django.db
        import django.test
    
        if transactional:
            test_case_class = django.test.TransactionTestCase
        else:
            test_case_class = django.test.TestCase
    
        _reset_sequences = reset_sequences
        _serialized_rollback = serialized_rollback
        _databases = databases
        _available_apps = available_apps
    
        class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
            reset_sequences = _reset_sequences
            serialized_rollback = _serialized_rollback
            if _databases is not None:
                databases = _databases
            if _available_apps is not None:
                available_apps = _available_apps
    
            # For non-transactional tests, skip executing `django.test.TestCase`'s
            # `setUpClass`/`tearDownClass`, only execute the super class ones.
            #
            # `TestCase`'s class setup manages the `setUpTestData`/class-level
            # transaction functionality. We don't use it; instead we (will) offer
            # our own alternatives. So it only adds overhead, and does some things
            # which conflict with our (planned) functionality, particularly, it
            # closes all database connections in `tearDownClass` which inhibits
            # wrapping tests in higher-scoped transactions.
            #
            # It's possible a new version of Django will add some unrelated
            # functionality to these methods, in which case skipping them completely
            # would not be desirable. Let's cross that bridge when we get there...
            if not transactional:
    
                @classmethod
                def setUpClass(cls) -&gt; None:
                    super(django.test.TestCase, cls).setUpClass()
                    if VERSION &lt; (4, 1):
                        django.db.transaction.Atomic._ensure_durability = False
    
                @classmethod
                def tearDownClass(cls) -&gt; None:
                    if VERSION &lt; (4, 1):
                        django.db.transaction.Atomic._ensure_durability = True
                    super(django.test.TestCase, cls).tearDownClass()
    
        PytestDjangoTestCase.setUpClass()
    
        test_case = PytestDjangoTestCase(methodName="__init__")
        test_case._pre_setup()
    
        yield
    
&gt;       test_case._post_teardown()

venv/lib/python3.12/site-packages/pytest_django/fixtures.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv/lib/python3.12/site-packages/django/test/testcases.py:1102: in _post_teardown
    self._fixture_teardown()
venv/lib/python3.12/site-packages/django/test/testcases.py:1333: in _fixture_teardown
    connections[db_name].check_constraints()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;DatabaseWrapper vendor='sqlite' alias='default'&gt;, table_names = None

    def check_constraints(self, table_names=None):
        """
        Check each table name in `table_names` for rows with invalid foreign
        key references. This method is intended to be used in conjunction with
        `disable_constraint_checking()` and `enable_constraint_checking()`, to
        determine if rows with invalid references were entered while constraint
        checks were off.
        """
        with self.cursor() as cursor:
            if table_names is None:
                violations = cursor.execute("PRAGMA foreign_key_check").fetchall()
            else:
                violations = chain.from_iterable(
                    cursor.execute(
                        "PRAGMA foreign_key_check(%s)" % self.ops.quote_name(table_name)
                    ).fetchall()
                    for table_name in table_names
                )
            # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
            for (
                table_name,
                rowid,
                referenced_table_name,
                foreign_key_index,
            ) in violations:
                foreign_key = cursor.execute(
                    "PRAGMA foreign_key_list(%s)" % self.ops.quote_name(table_name)
                ).fetchall()[foreign_key_index]
                column_name, referenced_column_name = foreign_key[3:5]
                primary_key_column_name = self.introspection.get_primary_key_column(
                    cursor, table_name
                )
                primary_key_value, bad_value = cursor.execute(
                    "SELECT %s, %s FROM %s WHERE rowid = %%s"
                    % (
                        self.ops.quote_name(primary_key_column_name),
                        self.ops.quote_name(column_name),
                        self.ops.quote_name(table_name),
                    ),
                    (rowid,),
                ).fetchone()
&gt;               raise IntegrityError(
                    "The row in table '%s' with primary key '%s' has an "
                    "invalid foreign key: %s.%s contains a value '%s' that "
                    "does not have a corresponding value in %s.%s."
                    % (
                        table_name,
                        primary_key_value,
                        table_name,
                        column_name,
                        bad_value,
                        referenced_table_name,
                        referenced_column_name,
                    )
                )
E               django.db.utils.IntegrityError: The row in table 'store_product' with primary key '1' has an invalid foreign key: store_product.category_id contains a value '1' that does not have a corresponding value in store_category.id.

venv/lib/python3.12/site-packages/django/db/backends/sqlite3/base.py:276: IntegrityError</error></testcase><testcase classname="ecom.cart.tests.test_views.TestCartViews" name="test_cart_delete" time="0.253"><failure message="AttributeError: 'Client' object has no attribute 'user'">self = &lt;test_views.TestCartViews object at 0x106c0b710&gt;
client = &lt;django.test.client.Client object at 0x10709c4d0&gt;

    def test_cart_delete(self, client):
        """Test deleting a product from the cart."""
        client.login(username="testuser", password="testpass")
        # Add product first
        cart = Cart(client)
&gt;       cart.add(product=self.product, quantity=2)

ecom/cart/tests/test_views.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;cart.cart.Cart object at 0x10709c830&gt;, product = &lt;Product: Test Product&gt;, quantity = 2

    def add(self, product, quantity):
        product_id = str(product.id)
        product_qty = str(quantity)
    
        if product_id in self.cart:
            pass
        else:
            # self.cart[product_id] = {'price': str(product.price)}
            self.cart[product_id] = int(product_qty)
    
        self.session.modified = True
&gt;       if self.request.user.is_authenticated:
E       AttributeError: 'Client' object has no attribute 'user'

ecom/cart/cart.py:43: AttributeError</failure></testcase><testcase classname="ecom.cart.tests.test_views.TestCartViews" name="test_cart_delete" time="0.000"><error message="failed on teardown with &quot;django.db.utils.IntegrityError: The row in table 'store_product' with primary key '1' has an invalid foreign key: store_product.category_id contains a value '1' that does not have a corresponding value in store_category.id.&quot;">request = &lt;SubRequest '_django_db_helper' for &lt;Function test_cart_delete&gt;&gt;
django_db_setup = None
django_db_blocker = &lt;pytest_django.plugin.DjangoDbBlocker object at 0x1056350d0&gt;

    @pytest.fixture()
    def _django_db_helper(
        request: pytest.FixtureRequest,
        django_db_setup: None,
        django_db_blocker: DjangoDbBlocker,
    ) -&gt; Generator[None, None, None]:
        from django import VERSION
    
        if is_django_unittest(request):
            yield
            return
    
        marker = request.node.get_closest_marker("django_db")
        if marker:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = validate_django_db(marker)
        else:
            (
                transactional,
                reset_sequences,
                databases,
                serialized_rollback,
                available_apps,
            ) = False, False, None, False, None
    
        transactional = (
            transactional
            or reset_sequences
            or ("transactional_db" in request.fixturenames or "live_server" in request.fixturenames)
        )
        reset_sequences = reset_sequences or ("django_db_reset_sequences" in request.fixturenames)
        serialized_rollback = serialized_rollback or (
            "django_db_serialized_rollback" in request.fixturenames
        )
    
        django_db_blocker.unblock()
    
        import django.db
        import django.test
    
        if transactional:
            test_case_class = django.test.TransactionTestCase
        else:
            test_case_class = django.test.TestCase
    
        _reset_sequences = reset_sequences
        _serialized_rollback = serialized_rollback
        _databases = databases
        _available_apps = available_apps
    
        class PytestDjangoTestCase(test_case_class):  # type: ignore[misc,valid-type]
            reset_sequences = _reset_sequences
            serialized_rollback = _serialized_rollback
            if _databases is not None:
                databases = _databases
            if _available_apps is not None:
                available_apps = _available_apps
    
            # For non-transactional tests, skip executing `django.test.TestCase`'s
            # `setUpClass`/`tearDownClass`, only execute the super class ones.
            #
            # `TestCase`'s class setup manages the `setUpTestData`/class-level
            # transaction functionality. We don't use it; instead we (will) offer
            # our own alternatives. So it only adds overhead, and does some things
            # which conflict with our (planned) functionality, particularly, it
            # closes all database connections in `tearDownClass` which inhibits
            # wrapping tests in higher-scoped transactions.
            #
            # It's possible a new version of Django will add some unrelated
            # functionality to these methods, in which case skipping them completely
            # would not be desirable. Let's cross that bridge when we get there...
            if not transactional:
    
                @classmethod
                def setUpClass(cls) -&gt; None:
                    super(django.test.TestCase, cls).setUpClass()
                    if VERSION &lt; (4, 1):
                        django.db.transaction.Atomic._ensure_durability = False
    
                @classmethod
                def tearDownClass(cls) -&gt; None:
                    if VERSION &lt; (4, 1):
                        django.db.transaction.Atomic._ensure_durability = True
                    super(django.test.TestCase, cls).tearDownClass()
    
        PytestDjangoTestCase.setUpClass()
    
        test_case = PytestDjangoTestCase(methodName="__init__")
        test_case._pre_setup()
    
        yield
    
&gt;       test_case._post_teardown()

venv/lib/python3.12/site-packages/pytest_django/fixtures.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv/lib/python3.12/site-packages/django/test/testcases.py:1102: in _post_teardown
    self._fixture_teardown()
venv/lib/python3.12/site-packages/django/test/testcases.py:1333: in _fixture_teardown
    connections[db_name].check_constraints()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;DatabaseWrapper vendor='sqlite' alias='default'&gt;, table_names = None

    def check_constraints(self, table_names=None):
        """
        Check each table name in `table_names` for rows with invalid foreign
        key references. This method is intended to be used in conjunction with
        `disable_constraint_checking()` and `enable_constraint_checking()`, to
        determine if rows with invalid references were entered while constraint
        checks were off.
        """
        with self.cursor() as cursor:
            if table_names is None:
                violations = cursor.execute("PRAGMA foreign_key_check").fetchall()
            else:
                violations = chain.from_iterable(
                    cursor.execute(
                        "PRAGMA foreign_key_check(%s)" % self.ops.quote_name(table_name)
                    ).fetchall()
                    for table_name in table_names
                )
            # See https://www.sqlite.org/pragma.html#pragma_foreign_key_check
            for (
                table_name,
                rowid,
                referenced_table_name,
                foreign_key_index,
            ) in violations:
                foreign_key = cursor.execute(
                    "PRAGMA foreign_key_list(%s)" % self.ops.quote_name(table_name)
                ).fetchall()[foreign_key_index]
                column_name, referenced_column_name = foreign_key[3:5]
                primary_key_column_name = self.introspection.get_primary_key_column(
                    cursor, table_name
                )
                primary_key_value, bad_value = cursor.execute(
                    "SELECT %s, %s FROM %s WHERE rowid = %%s"
                    % (
                        self.ops.quote_name(primary_key_column_name),
                        self.ops.quote_name(column_name),
                        self.ops.quote_name(table_name),
                    ),
                    (rowid,),
                ).fetchone()
&gt;               raise IntegrityError(
                    "The row in table '%s' with primary key '%s' has an "
                    "invalid foreign key: %s.%s contains a value '%s' that "
                    "does not have a corresponding value in %s.%s."
                    % (
                        table_name,
                        primary_key_value,
                        table_name,
                        column_name,
                        bad_value,
                        referenced_table_name,
                        referenced_column_name,
                    )
                )
E               django.db.utils.IntegrityError: The row in table 'store_product' with primary key '1' has an invalid foreign key: store_product.category_id contains a value '1' that does not have a corresponding value in store_category.id.

venv/lib/python3.12/site-packages/django/db/backends/sqlite3/base.py:276: IntegrityError</error></testcase></testsuite></testsuites>